#
#   eTTR: Enhanced Technical Trading Rules
#
#   Copyright (C) 2025 - 2030  DengYishuo
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#' Backtest trading signals with performance evaluation
#' @description This function performs a backtest based on trading signals generated by gen_Sig,
#' considering initial equity, transaction fees, closing prices, and optional exit strategies.
#' It returns a comprehensive backtest result including trade records, daily returns, and performance metrics.
#' @param signal_data Tibble containing trading signals and closing prices
#' @param initEq Numeric, initial equity (default: 10000)
#' @param fee Numeric, transaction fee rate (default: 0.001, 0.1%)
#' @param take_profit Numeric, take profit percentage (default: NULL, no take profit)
#' @param stop_loss Numeric, stop loss percentage (default: NULL, no stop loss)
#' @param max_holding_days Integer, maximum holding days (default: NULL, no limit)
#' @param date_col Character, name of the date column (default: "date")
#' @param signal_col Character, name of the signal column (default: "Signal")
#' @param price_col Character, name of the closing price column (default: "Close")
#' @return List containing:
#'   - trade_records: Data frame of trade details
#'   - daily_returns: Data frame of daily returns
#'   - performance: List of performance metrics
#' @export
#' @examples
#' \dontrun{
#' # Assume kdj_with_signal is the output from gen_Sig
#' backtest_result <- ebacktest(
#'   signal_data = kdj_with_signal,
#'   initEq = 10000,
#'   fee = 0.001,
#'   take_profit = 0.15, # 15% take profit
#'   stop_loss = -0.08, # 8% stop loss
#'   max_holding_days = 30 # 30 days maximum holding
#' )
#' }
ebacktest <- function(signal_data,
                      initEq = 10000,
                      fee = 0.001,
                      take_profit = NULL,
                      stop_loss = NULL,
                      max_holding_days = NULL,
                      date_col = "date",
                      signal_col = "Signal",
                      price_col = "Close") {
  # Validate input data
  if (!inherits(signal_data, "tbl")) {
    stop("signal_data must be a tibble")
  }

  if (!(date_col %in% colnames(signal_data) &&
    signal_col %in% colnames(signal_data) &&
    price_col %in% colnames(signal_data))) {
    missing_cols <- c(date_col, signal_col, price_col)[
      !c(date_col, signal_col, price_col) %in% colnames(signal_data)
    ]
    stop(sprintf("Missing required columns: %s", paste(missing_cols, collapse = ", ")))
  }

  # Validate exit strategy parameters
  if (!is.null(take_profit) && (take_profit <= 0 || take_profit > 1)) {
    stop("take_profit must be a positive number between 0 and 1")
  }

  if (!is.null(stop_loss) && (stop_loss >= 0 || stop_loss < -1)) {
    stop("stop_loss must be a negative number between -1 and 0")
  }

  if (!is.null(max_holding_days) && (max_holding_days <= 0 || !is.integer(as.integer(max_holding_days)))) {
    stop("max_holding_days must be a positive integer")
  }

  # Sort data by date
  signal_data <- signal_data[order(signal_data[[date_col]]), ]

  # Initialize variables
  n_days <- nrow(signal_data)
  cash <- initEq
  position <- 0
  buy_price <- 0 # Track buy price for take profit/stop loss calculations
  buy_date <- NULL # Track buy date for holding days calculation
  last_trade_date <- NULL
  trade_count <- 0
  trade_records <- list()
  daily_equity <- rep(0, n_days)
  daily_returns <- rep(0, n_days)

  # Backtest loop
  for (i in 1:n_days) {
    current_date <- signal_data[[date_col]][i]
    current_price <- signal_data[[price_col]][i]
    current_signal <- signal_data[[signal_col]][i]

    # Calculate daily equity (cash + position value)
    daily_equity[i] <- cash + position * current_price

    # Check if should exit based on take profit/stop loss/max holding days
    exit_reason <- NULL

    if (position > 0) { # Only check when holding a position
      holding_days <- if (!is.null(buy_date)) as.numeric(current_date - buy_date) else 0

      # Check take profit condition
      if (!is.null(take_profit) && current_price >= buy_price * (1 + take_profit)) {
        exit_reason <- "take_profit"
      }

      # Check stop loss condition
      else if (!is.null(stop_loss) && current_price <= buy_price * (1 + stop_loss)) {
        exit_reason <- "stop_loss"
      }

      # Check maximum holding days
      else if (!is.null(max_holding_days) && holding_days >= max_holding_days) {
        exit_reason <- "max_holding"
      }
    }

    # Process trading signals and automatic exit conditions
    if (!is.na(current_signal) || !is.null(exit_reason)) {
      # Buy logic (signal 1 and no position)
      if (current_signal == 1 && position == 0) {
        available_cash <- cash * 0.99 # Use 99% of available cash
        shares <- floor(available_cash / current_price)
        if (shares > 0) {
          trade_value <- shares * current_price
          trade_fee <- trade_value * fee
          cash <- cash - trade_value - trade_fee
          position <- shares
          buy_price <- current_price
          buy_date <- current_date
          trade_count <- trade_count + 1
          trade_records[[trade_count]] <- list(
            date = current_date,
            type = "buy",
            price = current_price,
            shares = shares,
            value = trade_value,
            fee = trade_fee,
            exit_reason = NA, # No exit reason for buys
            holding_days = NA
          )
          last_trade_date <- current_date
        }
      }

      # Sell logic (signal -1 or exit condition met with position)
      else if ((current_signal == -1 || !is.null(exit_reason)) && position > 0) {
        trade_value <- position * current_price
        trade_fee <- trade_value * fee
        cash <- cash + trade_value - trade_fee

        # Calculate holding days
        holding_days <- if (!is.null(buy_date)) as.numeric(current_date - buy_date) else NA

        trade_count <- trade_count + 1
        trade_records[[trade_count]] <- list(
          date = current_date,
          type = "sell",
          price = current_price,
          shares = position,
          value = trade_value,
          fee = trade_fee,
          exit_reason = if (!is.null(exit_reason)) exit_reason else "signal",
          holding_days = holding_days
        )

        position <- 0
        buy_price <- 0
        buy_date <- NULL
        last_trade_date <- current_date
      }
    }

    # Calculate daily return
    if (i > 1) {
      daily_returns[i] <- (daily_equity[i] / daily_equity[i - 1]) - 1
    } else {
      daily_returns[i] <- 0 # First day return is 0
    }
  }

  # Convert trade records to data frame
  trade_df <- if (trade_count > 0) {
    df <- do.call(rbind, lapply(trade_records, function(x) {
      x$date <- as.character(x$date) # Convert to character first for safe conversion
      as.data.frame(x, stringsAsFactors = FALSE)
    }))
    df$date <- as.Date(df$date) # Convert back to Date type
    df
  } else {
    data.frame()
  }

  # Format trade data types
  if (nrow(trade_df) > 0) {
    trade_df$shares <- as.integer(trade_df$shares)
    trade_df$value <- as.numeric(trade_df$value)
    trade_df$fee <- as.numeric(trade_df$fee)
    trade_df$holding_days <- as.integer(trade_df$holding_days)
    trade_df$exit_reason <- as.character(trade_df$exit_reason)
  }

  # Create daily returns tibble
  daily_returns_tbl <- tibble::as_tibble(cbind(
    date = as.character(signal_data[[date_col]]), # Convert to character first
    equity = daily_equity,
    return = daily_returns
  ))
  daily_returns_tbl$date <- as.Date(daily_returns_tbl$date) # Convert back to Date type
  daily_returns_tbl$equity <- as.numeric(daily_returns_tbl$equity)
  daily_returns_tbl$return <- as.numeric(daily_returns_tbl$return)

  # Calculate performance metrics
  performance <- calculate_performance(daily_returns_tbl$return, trade_df)

  # Return results
  list(
    trade_records = trade_df,
    daily_returns = daily_returns_tbl,
    performance = performance
  )
}

#' Calculate performance metrics (fixed trade pairing issue)
#' @param returns Numeric vector of daily returns
#' @param trades Data frame of trade records
#' @return List of performance metrics
calculate_performance <- function(returns, trades) {
  # Remove first day (return is 0)
  valid_returns <- returns[-1]

  # Total return
  total_return <- prod(1 + valid_returns) - 1

  # Annualized return
  n_days <- length(valid_returns)
  annualized_return <- if (n_days > 0) {
    (1 + total_return)^(252 / n_days) - 1
  } else {
    0
  }

  # Daily mean return
  mean_daily_return <- mean(valid_returns)

  # Daily standard deviation (volatility)
  volatility <- sd(valid_returns)

  # Sharpe ratio (risk-free rate assumed to be 0)
  sharpe_ratio <- ifelse(volatility > 0, mean_daily_return / volatility * sqrt(252), 0)

  # Maximum drawdown
  cum_returns <- cumsum(valid_returns)
  cum_equity <- exp(cum_returns)
  running_max <- cummax(cum_equity)
  drawdown <- (cum_equity / running_max) - 1
  max_drawdown <- min(drawdown)

  # VaR (Value at Risk) - 95% confidence level
  var_95 <- -quantile(valid_returns, 0.05, na.rm = TRUE)

  # ES (Expected Shortfall) - 95% confidence level
  es_95 <- if (length(valid_returns[valid_returns <= quantile(valid_returns, 0.05, na.rm = TRUE)]) > 0) {
    -mean(valid_returns[valid_returns <= quantile(valid_returns, 0.05, na.rm = TRUE)])
  } else {
    0
  }

  # Trade metrics
  if (nrow(trades) > 0) {
    buy_trades <- trades[trades$type == "buy", ]
    sell_trades <- trades[trades$type == "sell", ]

    if (nrow(buy_trades) > 0 && nrow(sell_trades) > 0) {
      # Match buy and sell trades
      trade_pairs <- list()
      buy_idx <- 1
      sell_idx <- 1

      # Improved trade pairing logic
      while (buy_idx <= nrow(buy_trades) && sell_idx <= nrow(sell_trades)) {
        buy_date <- buy_trades$date[buy_idx]
        sell_date <- sell_trades$date[sell_idx]

        if (buy_date < sell_date) {
          # Find matching sell trade
          next_sell_idx <- sell_idx
          while (next_sell_idx <= nrow(sell_trades) &&
            sell_trades$date[next_sell_idx] <= buy_date) {
            next_sell_idx <- next_sell_idx + 1
          }

          if (next_sell_idx <= nrow(sell_trades)) {
            trade_pairs[[length(trade_pairs) + 1]] <- list(
              buy = buy_trades[buy_idx, ],
              sell = sell_trades[next_sell_idx, ]
            )
            buy_idx <- buy_idx + 1
            sell_idx <- next_sell_idx + 1
          } else {
            # No matching sell trade, skip this buy
            buy_idx <- buy_idx + 1
          }
        } else {
          # Current sell is earlier than current buy, find next sell
          sell_idx <- sell_idx + 1
        }
      }

      # Calculate trade returns
      if (length(trade_pairs) > 0) {
        trade_returns <- numeric()
        holding_days <- numeric()
        exit_reasons <- character()

        for (i in 1:length(trade_pairs)) {
          buy <- trade_pairs[[i]]$buy
          sell <- trade_pairs[[i]]$sell
          trade_return <- (sell$value - buy$value - buy$fee - sell$fee) / buy$value
          trade_returns <- c(trade_returns, trade_return)
          holding_days <- c(holding_days, sell$holding_days)
          exit_reasons <- c(exit_reasons, sell$exit_reason)
        }

        # Win rate
        win_rate <- mean(trade_returns > 0) * 100

        # Average holding days
        avg_holding_days <- mean(holding_days, na.rm = TRUE)

        # Max holding days
        max_holding_days <- max(holding_days, na.rm = TRUE)

        # Number of trades
        n_trades <- length(trade_returns)

        # Trade counts by exit reason
        exit_reason_counts <- table(exit_reasons)
      } else {
        # No paired trades
        win_rate <- 0
        avg_holding_days <- 0
        max_holding_days <- 0
        n_trades <- 0
        exit_reason_counts <- NULL
      }
    } else {
      # No buy or sell trades
      win_rate <- 0
      avg_holding_days <- 0
      max_holding_days <- 0
      n_trades <- 0
      exit_reason_counts <- NULL
    }
  } else {
    # No trade records
    win_rate <- 0
    avg_holding_days <- 0
    max_holding_days <- 0
    n_trades <- 0
    exit_reason_counts <- NULL
  }

  # Compile performance metrics
  list(
    total_return = total_return,
    annualized_return = annualized_return,
    mean_daily_return = mean_daily_return,
    volatility = volatility,
    sharpe_ratio = sharpe_ratio,
    max_drawdown = max_drawdown,
    var_95 = var_95,
    es_95 = es_95,
    n_trades = n_trades,
    win_rate = win_rate,
    avg_holding_days = avg_holding_days,
    max_holding_days = max_holding_days,
    exit_reason_counts = exit_reason_counts
  )
}
